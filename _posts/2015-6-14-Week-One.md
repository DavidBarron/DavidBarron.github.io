---
layout: post
title: Week One
---

It’s nearly impossible to be a student of the UT computer science department without hearing a story or two about Professor Downing. Spending any kind of time in one of the campus computer science labs will grant the opportunity to overhear a tired student grumble about his class workload, with the word ‘Downing’ inserted somewhere to identify the source of his dilemmas. It was because of experiences like this that I was initially hesitant to sign up for one of his classes, especially an accelerated summer version of one. I decided to ask for a second opinion from a couple of friends who had previously been in one of his classes, and to my surprise they really recommended I take one. They did confirm I would have to work quite a bit to get a good grade, but the things I would be learning from Professor Downing would be invaluable. So, I bit the bullet and that is why I am now sitting here working on one of his extra credit opportunities: this blog.
The first week of Software Engineering was pretty straight forward. We spent almost an entire period going over the requirements for the first project, and while I thought it was a bit unnecessary, it did serve to underline the amount of detail Professor Downing expects us to observe in projects going forward. This specific project dealt with the Collatz Conjecture; for any integer n greater than 1, if n is even it is divided by 2 or if n is odd it is multiplied by 3 and incremented by 1, this process is repeated until we reach n equal to 1. According to Professor Downing no formal proof exists of this algorithm terminating exists, but we should be able to see that it does in our project. 
Something that is really interesting (and refreshing) about Professor Downing is the level of participation he likes to see from his students. Unlike other professors who also expect class participation, there are no awkward moments of silence as the professor waits for someone to answer a question, and instead he simple calls on a random person from his list to talk him through the current problem. I like this because it keeps the flow of the class and because it removes some of the pressure from students to raise hands and engage socially. 
Finally, Python. I remember using Python in my physics classes as a modeling tool, but that only amounted to changing the values of some variables or filling in simple functions. I never really got to experience the intricacies of the language, which it turns out is quite different than C and Java. Arguable the most important of these differences in Python is that variables have no specific type attached to them, so a variable that is assigned an integer can later be assigned a string with no additional effort from the programmer’s perspective. It is because of this quality that it becomes imperative to check the type of return values from functions to assure oneself that a critical mistake didn’t occur. I’m sure there’s plenty more I will learn as the class goes on, especially from JavaScript which we have only discussed in class up until now.
